# Story 4.1: Symbol Detection Engine

**Status:** Approved

## Story

**As an** electrical professional using the electrical drawing analysis app  
**I want** automatic detection and recognition of electrical symbols in uploaded drawings  
**So that** I can quickly identify what components are present without manual symbol lookup  

## Acceptance Criteria

From Epic 4, Story 4.1 requirements:
1. [ ] Computer vision pipeline that processes PDF images for electrical symbol detection
2. [ ] Symbol recognition algorithms using pattern matching with electrical component library
3. [ ] Machine learning-based classification for standard electrical symbols (resistors, capacitors, transistors, etc.)
4. [ ] Confidence scoring system for each detected symbol (0.0-1.0 scale)
5. [ ] Location tracking with normalized coordinates for symbol positions
6. [ ] Integration with existing LLM ensemble for enhanced symbol interpretation
7. [ ] Symbol detection results stored in database with structured metadata
8. [ ] 90% accuracy rate on standard electrical symbols from industry libraries
9. [ ] Processing time under 30 seconds per PDF page for symbol detection
10. [ ] Error handling for unclear, hand-drawn, or non-standard symbols
11. [ ] Detection result validation and false positive filtering
12. [ ] API endpoints for triggering and retrieving symbol detection results

## Tasks / Subtasks

### Core Symbol Detection Infrastructure Tasks
- [ ] **Task 4.1.1**: Build Computer Vision Pipeline Foundation (AC: 1, 9)
  - [ ] Create SymbolDetectionService in llm-orchestrator service
  - [ ] Implement PDF to image conversion with proper resolution optimization
  - [ ] Build image preprocessing pipeline (noise reduction, contrast enhancement, edge detection)
  - [ ] Create coordinate normalization system for symbol locations across different PDF scales
  - [ ] Implement processing queue system using Bull for handling detection jobs
  - [ ] Add comprehensive error handling for corrupted or invalid image data

- [ ] **Task 4.1.2**: Implement Symbol Recognition Engine (AC: 2, 3, 8)
  - [ ] Create ElectricalSymbolLibrary with standard symbols (resistors, capacitors, inductors, transistors, ICs, connectors)
  - [ ] Build pattern matching algorithms using OpenCV contour detection and template matching
  - [ ] Implement machine learning classification using pre-trained models for electrical symbols
  - [ ] Create symbol feature extraction system (shape analysis, geometric properties, connection points)
  - [ ] Build symbol classification with hierarchical categorization (passive, active, connectors, etc.)
  - [ ] Add support for symbol rotation and scaling invariance

### Confidence and Validation System Tasks
- [ ] **Task 4.1.3**: Build Confidence Scoring and Validation System (AC: 4, 10, 11)
  - [ ] Implement multi-factor confidence scoring (pattern match score, ML prediction confidence, context validation)
  - [ ] Create validation system using symbol context (electrical circuit rules, component relationships)
  - [ ] Build false positive filtering based on electrical engineering principles
  - [ ] Implement uncertainty handling for ambiguous or unclear symbols
  - [ ] Add confidence threshold configuration for different detection sensitivity levels
  - [ ] Create detection quality metrics and validation reporting

- [ ] **Task 4.1.4**: Integrate with LLM Ensemble and Database Storage (AC: 5, 6, 7)
  - [ ] Extend existing LLMProvider interfaces to support symbol detection alongside text analysis
  - [ ] Create SymbolDetectionResult data models and database schema extensions
  - [ ] Implement storage system for detection results with metadata (coordinates, confidence, symbol type)
  - [ ] Build integration with existing consensus system for multi-model symbol validation
  - [ ] Add support for LLM-enhanced symbol interpretation for complex or custom symbols
  - [ ] Create detection result caching and session management

### API and Performance Optimization Tasks
- [ ] **Task 4.1.5**: Build API Endpoints and Performance Optimization (AC: 9, 12)
  - [ ] Create RESTful API endpoints for triggering symbol detection jobs
  - [ ] Implement WebSocket events for real-time detection progress updates
  - [ ] Build detection result retrieval APIs with filtering and pagination
  - [ ] Add processing time optimization with parallel processing and image chunking
  - [ ] Implement caching strategy for previously processed documents
  - [ ] Create performance monitoring and benchmarking for detection speed and accuracy

- [ ] **Task 4.1.6**: Testing and Integration with Existing Systems (AC: 1-12)
  - [ ] Create comprehensive unit tests for all symbol detection components
  - [ ] Build integration tests with existing PDF processing and LLM orchestrator systems
  - [ ] Implement end-to-end tests for complete symbol detection workflow
  - [ ] Add performance benchmarks to ensure 30-second processing time requirement
  - [ ] Create accuracy validation tests using known electrical drawing test sets
  - [ ] Build error handling tests for edge cases and malformed inputs

## Dev Notes

### Previous Story Insights
From Story 3.4 (Visual Element Highlighting) completion, key learnings relevant to symbol detection:
- Visual coordinate mapping systems are established for PDF overlays and highlighting
- Component identification data structures exist with location tracking and confidence scoring
- Frontend highlighting infrastructure can be extended to show detected symbols
- PDF rendering pipeline supports overlay systems that can display detection results
- Session-based context management provides framework for storing detection state

### Architecture Context

#### Backend Symbol Detection Architecture
[Source: architecture/source-tree.md#Backend Structure]
Primary implementation location for symbol detection engine:
- `backend/services/llm-orchestrator/src/` - Main service for AI/ML operations
- `backend/services/llm-orchestrator/src/providers/` - Extend existing provider pattern for symbol detection
- `backend/services/llm-orchestrator/src/detection/` - NEW: Symbol detection engine components
- `backend/services/llm-orchestrator/src/vision/` - NEW: Computer vision processing utilities
- `backend/shared/types/` - Extend with symbol detection data types

Expected directory structure extension:
```
backend/services/llm-orchestrator/src/
├── providers/                          # EXISTING: LLM provider implementations
│   ├── openai.provider.ts             # EXISTING: Extend with vision capabilities
│   ├── claude.provider.ts             # EXISTING: Extend with vision capabilities
│   └── symbol-detection.provider.ts    # NEW: Dedicated symbol detection provider
├── detection/                          # NEW: Symbol detection engine
│   ├── symbol-detector.ts             # NEW: Main detection orchestrator
│   ├── pattern-matcher.ts             # NEW: Template matching algorithms
│   ├── ml-classifier.ts               # NEW: Machine learning classification
│   ├── confidence-scorer.ts           # NEW: Multi-factor confidence calculation
│   └── symbol-validator.ts            # NEW: False positive filtering
├── vision/                             # NEW: Computer vision utilities
│   ├── image-processor.ts             # NEW: Image preprocessing and enhancement
│   ├── feature-extractor.ts           # NEW: Symbol feature analysis
│   ├── coordinate-mapper.ts           # NEW: PDF coordinate normalization
│   └── symbol-library.ts              # NEW: Electrical symbol reference library
├── consensus/                          # EXISTING: Extend for symbol consensus
│   ├── aggregator.ts                  # EXISTING: Extend with symbol detection results
│   └── confidence.ts                  # EXISTING: Extend with symbol confidence scoring
└── controllers/
    └── symbol-detection.controller.ts  # NEW: API endpoints for symbol detection
```

#### Data Models for Symbol Detection
[Source: architecture/data-models.md#Core Data Types]
```typescript
// Symbol Detection Interfaces
interface SymbolDetectionResult {
  id: string
  queryId: string
  documentId: string
  pageNumber: number
  detectedSymbols: DetectedSymbol[]
  processingTimeMs: number
  overallConfidence: number
  detectionMetadata: DetectionMetadata
  createdAt: Date
}

interface DetectedSymbol {
  id: string
  symbolType: ElectricalSymbolType
  symbolCategory: SymbolCategory
  description: string
  confidence: number
  location: SymbolLocation
  boundingBox: BoundingBox
  detectionMethod: DetectionMethod
  features: SymbolFeatures
  validationScore: number
}

interface SymbolLocation {
  x: number              // Normalized coordinates (0-1)
  y: number              // Normalized coordinates (0-1)
  pageNumber: number
  originalX: number      // Original pixel coordinates
  originalY: number      // Original pixel coordinates
  imageWidth: number     // Original image dimensions
  imageHeight: number
}

interface BoundingBox {
  x: number              // Top-left corner
  y: number              // Top-left corner  
  width: number
  height: number
  rotation?: number      // Symbol rotation angle
  area: number          // Bounding box area
}

interface SymbolFeatures {
  contourPoints: Point[]
  geometricProperties: GeometricProperties
  connectionPoints: ConnectionPoint[]
  shapeAnalysis: ShapeAnalysis
  textLabels?: string[]
}

interface GeometricProperties {
  area: number
  perimeter: number
  centroid: Point
  boundaryRectangle: BoundingBox
  symmetryAxes: SymmetryAxis[]
  aspectRatio: number
}

interface ConnectionPoint {
  location: Point
  type: 'input' | 'output' | 'bidirectional' | 'ground'
  connectedTo?: string[]   // IDs of connected symbols
}

interface DetectionMetadata {
  imageProcessingTime: number
  patternMatchingTime: number
  mlClassificationTime: number
  validationTime: number
  totalProcessingTime: number
  imageQuality: ImageQuality
  detectionSettings: DetectionSettings
}

type ElectricalSymbolType = 
  | 'resistor' | 'capacitor' | 'inductor' | 'diode' | 'transistor'
  | 'integrated_circuit' | 'connector' | 'switch' | 'relay' | 'transformer'
  | 'ground' | 'power_supply' | 'battery' | 'fuse' | 'led'
  | 'operational_amplifier' | 'logic_gate' | 'custom' | 'unknown'

type SymbolCategory = 'passive' | 'active' | 'connector' | 'power' | 'protection' | 'logic' | 'custom'

type DetectionMethod = 'pattern_matching' | 'ml_classification' | 'llm_analysis' | 'consensus'

interface ImageQuality {
  resolution: number
  clarity: number        // 0-1 scale
  contrast: number       // 0-1 scale
  noiseLevel: number     // 0-1 scale
  skewAngle?: number     // Document skew in degrees
}
```

#### Database Schema Extensions for Symbol Detection
[Source: architecture/3-detailed-component-architecture.md#Database Schema Design]
Database schema extensions for symbol detection storage:
```sql
-- Symbol detection results table
CREATE TABLE electrical_analysis.symbol_detection_results (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    query_id UUID REFERENCES electrical_analysis.queries(id) ON DELETE CASCADE,
    document_id UUID REFERENCES electrical_analysis.documents(id) ON DELETE CASCADE,
    page_number INTEGER NOT NULL DEFAULT 1,
    processing_time_ms INTEGER NOT NULL,
    overall_confidence DECIMAL(3,2) CHECK (overall_confidence >= 0 AND overall_confidence <= 1),
    detection_metadata JSONB NOT NULL DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Detected symbols table
CREATE TABLE electrical_analysis.detected_symbols (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    detection_result_id UUID REFERENCES electrical_analysis.symbol_detection_results(id) ON DELETE CASCADE,
    symbol_type VARCHAR(50) NOT NULL,
    symbol_category VARCHAR(20) NOT NULL CHECK (symbol_category IN ('passive', 'active', 'connector', 'power', 'protection', 'logic', 'custom')),
    description TEXT,
    confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
    location_x DECIMAL(8,4) NOT NULL,      -- Normalized coordinates
    location_y DECIMAL(8,4) NOT NULL,      -- Normalized coordinates
    original_x INTEGER,                     -- Original pixel coordinates
    original_y INTEGER,                     -- Original pixel coordinates
    bounding_box JSONB NOT NULL,           -- {x, y, width, height, rotation?, area}
    symbol_features JSONB DEFAULT '{}',    -- Geometric and visual features
    detection_method VARCHAR(30) NOT NULL CHECK (detection_method IN ('pattern_matching', 'ml_classification', 'llm_analysis', 'consensus')),
    validation_score DECIMAL(3,2) CHECK (validation_score >= 0 AND validation_score <= 1),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Symbol library reference table for pattern matching
CREATE TABLE electrical_analysis.symbol_library (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    symbol_type VARCHAR(50) NOT NULL,
    symbol_category VARCHAR(20) NOT NULL,
    symbol_name VARCHAR(100) NOT NULL,
    symbol_description TEXT,
    template_data BYTEA,                    -- Template image data for pattern matching
    feature_vector JSONB,                   -- Extracted features for ML classification
    industry_standard VARCHAR(50),          -- IEEE, IEC, ANSI, etc.
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    version INTEGER DEFAULT 1
);

-- Detection performance metrics
CREATE TABLE electrical_analysis.detection_metrics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    detection_result_id UUID REFERENCES electrical_analysis.symbol_detection_results(id) ON DELETE CASCADE,
    metric_type VARCHAR(30) NOT NULL,      -- 'processing_time', 'accuracy', 'false_positive_rate'
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit VARCHAR(20),               -- 'ms', 'percentage', etc.
    benchmark_comparison JSONB,            -- Comparison with benchmarks
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_symbol_detection_results_query_id ON electrical_analysis.symbol_detection_results(query_id);
CREATE INDEX idx_symbol_detection_results_document_id ON electrical_analysis.symbol_detection_results(document_id);
CREATE INDEX idx_detected_symbols_detection_result_id ON electrical_analysis.detected_symbols(detection_result_id);
CREATE INDEX idx_detected_symbols_type_category ON electrical_analysis.detected_symbols(symbol_type, symbol_category);
CREATE INDEX idx_symbol_library_type_category ON electrical_analysis.symbol_library(symbol_type, symbol_category);
```

#### API Endpoints for Symbol Detection System
[Source: architecture/5-api-specifications-and-integration-patterns.md#Core API Endpoints]
New endpoints for symbol detection:
- `POST /api/sessions/{sessionId}/documents/{documentId}/detect-symbols` - Trigger symbol detection
- `GET /api/sessions/{sessionId}/detection-results/{resultId}` - Get detection results
- `GET /api/sessions/{sessionId}/detection-results` - List all detection results for session
- `PUT /api/sessions/{sessionId}/detection-results/{resultId}/validate` - Validate/correct detection results
- `DELETE /api/sessions/{sessionId}/detection-results/{resultId}` - Delete detection results
- `GET /api/symbol-library` - Get available symbol types and categories
- `POST /api/symbol-library/validate` - Validate custom symbol against library

#### WebSocket Events for Real-time Symbol Detection
[Source: architecture/3-detailed-component-architecture.md#WebSocket Communication]
Extended WebSocket events for symbol detection:
```typescript
interface SymbolDetectionWebSocketEvents {
  // Client to Server
  'start-symbol-detection': { documentId: string, sessionId: string, options?: DetectionOptions }
  'cancel-symbol-detection': { detectionJobId: string }
  
  // Server to Client
  'symbol-detection-started': { jobId: string, estimatedTime: number }
  'symbol-detection-progress': { jobId: string, progress: number, stage: string, currentSymbol?: string }
  'symbol-detection-completed': { jobId: string, result: SymbolDetectionResult }
  'symbol-detection-error': { jobId: string, error: string, details?: any }
  'symbol-detected': { symbol: DetectedSymbol, totalFound: number }
}
```

### Technology Stack Requirements
[Source: architecture/tech-stack.md#Backend Technologies]
- **Node.js 18+ LTS**: Runtime environment for symbol detection service
- **TypeScript 5.0+**: Type safety for complex computer vision data structures
- **OpenCV.js or Sharp**: Image processing and computer vision operations
- **TensorFlow.js or ONNX Runtime**: Machine learning inference for symbol classification
- **Bull 4.0+**: Job queue for processing symbol detection tasks
- **PostgreSQL 15+**: Database storage for detection results and symbol library
- **Redis 7.0+**: Caching for detection results and symbol templates

### File Locations and Structure
[Source: architecture/source-tree.md#Backend Structure]
Primary implementation locations for symbol detection engine:
- `backend/services/llm-orchestrator/src/detection/symbol-detector.ts` - Main detection orchestrator
- `backend/services/llm-orchestrator/src/vision/image-processor.ts` - Image preprocessing utilities
- `backend/services/llm-orchestrator/src/detection/pattern-matcher.ts` - Template matching algorithms
- `backend/services/llm-orchestrator/src/detection/ml-classifier.ts` - Machine learning classification
- `backend/services/llm-orchestrator/src/controllers/symbol-detection.controller.ts` - API endpoints
- `backend/shared/types/symbol-detection.types.ts` - TypeScript type definitions

### Performance Requirements
Symbol detection must meet processing time and accuracy targets:
- Detection processing: <30 seconds per PDF page as specified in AC 9
- Symbol recognition accuracy: >90% on standard electrical symbols as specified in AC 8
- Memory efficiency: Proper cleanup of image processing resources
- Concurrent processing: Support multiple detection jobs simultaneously
- Database performance: Efficient storage and retrieval of detection results
- API responsiveness: Real-time progress updates via WebSocket

### Error Handling Requirements
[Source: architecture/coding-standards.md#Backend Error Handling]
Symbol detection error scenarios:
- Invalid or corrupted image data (graceful degradation with error reporting)
- Unsupported symbol types (fallback to generic detection with lower confidence)
- Processing timeout scenarios (partial results with timeout indication)
- Machine learning model failures (fallback to pattern matching methods)
- Database storage failures (temporary caching with retry mechanisms)
- Memory overflow protection (processing limits and resource cleanup)

### Integration with Existing Systems
Symbol detection must integrate seamlessly with:
- **PDF Processing Pipeline**: Extend existing document processing with symbol detection stage
- **LLM Orchestrator**: Integrate detection results with text-based analysis for enhanced understanding
- **Database Schema**: Extend existing tables while maintaining referential integrity
- **Session Management**: Symbol detection results tied to session lifecycle and cleanup policies
- **WebSocket Communication**: Real-time updates integrated with existing progress notification system
- **Visual Highlighting**: Detection results compatible with highlighting system from Story 3.4

### Testing

Testing standards from architecture documentation:
- **Unit Tests**: Jest with 90%+ code coverage requirement on all symbol detection components
- **Computer Vision Testing**: Accuracy validation using known electrical symbol test datasets
- **Integration Testing**: Full pipeline testing with PDF processing, LLM orchestrator, and database storage
- **Performance Testing**: Processing time validation and memory usage monitoring
- **API Testing**: Complete endpoint testing with various symbol detection scenarios
- **Test Locations**: 
  - `backend/services/llm-orchestrator/src/detection/__tests__/symbol-detector.test.ts`
  - `backend/services/llm-orchestrator/src/vision/__tests__/image-processor.test.ts`
  - `backend/services/llm-orchestrator/src/detection/__tests__/pattern-matcher.test.ts`
  - `backend/services/llm-orchestrator/src/controllers/__tests__/symbol-detection.controller.test.ts`
- **Mock Strategy**: Mock image processing libraries, ML model inference, and database operations
- **Performance Testing**: Benchmark testing with various PDF complexity levels and symbol densities
- **Accuracy Testing**: Validation against electrical engineering symbol standards (IEEE, IEC, ANSI)

## Dev Agent Record

### Agent Model Used
Claude 4 (Sonnet) - January 2025

### Debug Log References
(To be filled by Dev Agent)

### Completion Notes List
(To be filled by Dev Agent)

### File List
(To be filled by Dev Agent)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-05 | 1.0 | Initial story creation for Symbol Detection Engine | Bob (Scrum Master) |
| 2025-08-05 | 1.1 | Story approved after comprehensive PO validation - ready for implementation | Sarah (Product Owner) |